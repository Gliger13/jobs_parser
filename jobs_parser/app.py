from business.parse_results import ParseResults
from business.urls_collector import UrlsCollector, PaginatorUrlsCollector
from business.web_parser import WebParser
from settings import logger


def parse_required(func):
    def wrapper(self, *args, **kwargs):
        if not self.parse_results:
            self.parse()
        return func(self, *args, **kwargs)
    return wrapper


class App:
    """
    Application that searches for specific words in urls that generated by herself by url template

    Application searches for the specified words in urls. Excludes blocks of text from the search by their class div
    name. Collects all links from the paginator page or just by the name of the link class. These paginator pages are
    also generated from a single template. Based on the results of parsing, it displays the total number of found words
    and their average value per page.


    Parameters
    ----------
    first_paginator_url_template: str
        URL to the first page of the paginator as str like "https://site/page={page_number}"
    words_to_find: [str]
        The list of words to find in pages
    block_link_class: str, optional
        The name of the class of urls to get them
    classes_to_exclude: [str], optional
        Exclude blocks of text by the name of their class divs
    request_headers: dict, optional
        The headers of request
    start_page: int, optional
        Starting page number of paginator
    end_page: int, optional
        Paginator end page number
    """
    def __init__(
            self, first_paginator_url_template: str, words_to_find: [str], /,
            block_link_class: str = None, classes_to_exclude: [str] = (),
            request_headers: dict = None, start_page: int = None, end_page: int = None
    ):
        self.first_paginator_url_template = first_paginator_url_template
        self.words_to_find = words_to_find

        self.block_link_class = block_link_class
        self.classes_to_exclude = classes_to_exclude

        self.request_headers = request_headers
        self.start_page = start_page
        self.end_page = end_page

        self.parse_results = None

    def _paginator_urls(self) -> [str]:
        collector = PaginatorUrlsCollector(self.first_paginator_url_template, self.request_headers)
        return collector.valid_paginator_urls(self.start_page, self.end_page)

    def _urls_to_parse(self) -> [str]:
        return UrlsCollector(self._paginator_urls(), self.block_link_class, self.request_headers).collect_urls()

    def parse(self) -> ParseResults:
        self.parse_results = WebParser(
            self._urls_to_parse(), self.words_to_find, self.classes_to_exclude, self.request_headers
        ).parse()
        return self.parse_results

    @parse_required
    def num_of_word_occur_str(self):
        text_template = "Amount of occurrences of the word {0} per vacancy page is {1}."
        text = [text_template.format(w, num) for w, num in self.parse_results.count_words_occurrence().items()]
        return '\n'.join(text)

    @parse_required
    def average_num_of_occur_str(self):
        text_template = "Average number of occurrence of the word {0} is {1}."
        text = [text_template.format(w, num) for w, num in self.parse_results.average_num_of_words_occur().items()]
        return '\n'.join(text)


if __name__ == '__main__':
    paginator_url_template = "https://rabota.by/search/vacancy?text=Python&page={page_number}"
    words = [r'python', r'linux', r'flask']

    link_class = 'bloko-link HH-LinkModifier'
    div_classes = ['recommended-vacancies', 'related-vacancies-wrapper']
    headers = {'user-agent': 'job_parser/1.1.1'}

    app = App(
        paginator_url_template, words,
        block_link_class=link_class, classes_to_exclude=div_classes,
        request_headers=headers, start_page=0, end_page=3
    )
    app.parse()
    print(app.average_num_of_occur_str())
    print(app.num_of_word_occur_str())
